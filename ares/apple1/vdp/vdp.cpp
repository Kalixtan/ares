#include <apple1/apple1.hpp>

namespace ares::Apple1 {

VDP vdp;
#include "color.cpp"
#include "serialization.cpp"

auto VDP::main() -> void {
  
  int S2513[512] = {
		0x00, 0x0e, 0x11, 0x15, 0x17, 0x16, 0x10, 0x0f,  // @
		0x00, 0x04, 0x0a, 0x11, 0x11, 0x1f, 0x11, 0x11,  // A
		0x00, 0x1e, 0x11, 0x11, 0x1e, 0x11, 0x11, 0x1e,  // B
		0x00, 0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e,  // C
		0x00, 0x1e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1e,  // D
		0x00, 0x1f, 0x10, 0x10, 0x1e, 0x10, 0x10, 0x1f,  // E
		0x00, 0x1f, 0x10, 0x10, 0x1e, 0x10, 0x10, 0x10,  // F
		0x00, 0x0f, 0x10, 0x10, 0x10, 0x13, 0x11, 0x0f,  // G
		0x00, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11,  // H
		0x00, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0e,  // I
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x0e,  // J
		0x00, 0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11,  // K
		0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f,  // L
		0x00, 0x11, 0x1b, 0x15, 0x15, 0x11, 0x11, 0x11,  // M
		0x00, 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11,  // N
		0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e,  // O
		0x00, 0x1e, 0x11, 0x11, 0x1e, 0x10, 0x10, 0x10,  // P
		0x00, 0x0e, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0d,  // Q
		0x00, 0x1e, 0x11, 0x11, 0x1e, 0x14, 0x12, 0x11,  // R
		0x00, 0x0e, 0x11, 0x10, 0x0e, 0x01, 0x11, 0x0e,  // S
		0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,  // T
		0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e,  // U
		0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0a, 0x04,  // V
		0x00, 0x11, 0x11, 0x11, 0x15, 0x15, 0x1b, 0x11,  // W
		0x00, 0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11,  // X
		0x00, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04,  // Y
		0x00, 0x1f, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1f,  // Z
		0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f,  // [
		0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00,  // \
		0x00, 0x1f, 0x03, 0x03, 0x03, 0x03, 0x03, 0x1f,  // ]
		0x00, 0x00, 0x00, 0x04, 0x0a, 0x11, 0x00, 0x00,  // ^
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,  // _
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //  
		0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04,  // |
		0x00, 0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00,  // "
		0x00, 0x0a, 0x0a, 0x1f, 0x0a, 0x1f, 0x0a, 0x0a,  // #
		0x00, 0x04, 0x0f, 0x14, 0x0e, 0x05, 0x1e, 0x04,  // $
		0x00, 0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03,  // %
		0x00, 0x08, 0x14, 0x14, 0x08, 0x15, 0x12, 0x0d,  // &
		0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00,  // '
		0x00, 0x04, 0x08, 0x10, 0x10, 0x10, 0x08, 0x04,  // (
		0x00, 0x04, 0x02, 0x01, 0x01, 0x01, 0x02, 0x04,  // )
		0x00, 0x04, 0x15, 0x0e, 0x04, 0x0e, 0x15, 0x04,  // *
		0x00, 0x00, 0x04, 0x04, 0x1f, 0x04, 0x04, 0x00,  // +
		0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x08,  // ,
		0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00,  // -
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,  // .
		0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00,  // /
		0x00, 0x0e, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0e,  // 0
		0x00, 0x04, 0x0c, 0x04, 0x04, 0x04, 0x04, 0x0e,  // 1
		0x00, 0x0e, 0x11, 0x01, 0x06, 0x08, 0x10, 0x1f,  // 2
		0x00, 0x1f, 0x01, 0x02, 0x06, 0x01, 0x11, 0x0e,  // 3
		0x00, 0x02, 0x06, 0x0a, 0x12, 0x1f, 0x02, 0x02,  // 4
		0x00, 0x1f, 0x10, 0x1e, 0x01, 0x01, 0x11, 0x0e,  // 5
		0x00, 0x07, 0x08, 0x10, 0x1e, 0x11, 0x11, 0x0e,  // 6
		0x00, 0x1f, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08,  // 7
		0x00, 0x0e, 0x11, 0x11, 0x0e, 0x11, 0x11, 0x0e,  // 8
		0x00, 0x0e, 0x11, 0x11, 0x0f, 0x01, 0x02, 0x1c,  // 9
		0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00,  // :
		0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x08,  // ;
		0x00, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02,  // <
		0x00, 0x00, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x00,  // =
		0x00, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08,  // >
		0x00, 0x0e, 0x11, 0x02, 0x04, 0x04, 0x00, 0x04,  // ?
  };
  
  const auto pixel = (vcounter * screen->width()) + hcounter;
  const auto tile_index  = ((vcounter>>3) * 32) + (hcounter>>3);
  auto buffer = screen->pixels().data();
  
  const auto tile_x  = hcounter&7;
  const auto tile_y  = vcounter&7;
  const auto tile_i  = (tile_index&0xff) & 0b111111;
  
  
  const auto byte = S2513[tile_y+(tile_i<<3)];
  buffer[pixel] = (byte>>(4-tile_x))&1;
  
  
  // DEBUG CURSOR //
  if (hcounter>>3 == cursx && vcounter>>3 == cursy){
    buffer[pixel] = 2-buffer[pixel];
  }
  
  
  step(1);
  
  hcounter++;
  if (hcounter == 32*8) {
    hcounter = 0;
    vcounter++;
    if (vcounter == 24*8) {
      vcounter = 0;
      
      frame();
    }
  }
}

auto VDP::load(Node::Object parent) -> void {
  node = parent->append<Node::Object>("VDP");

  screen = node->append<Node::Video::Screen>("Screen", 32*8, 24*8);
  screen->colors(3, {&VDP::color, this});
  screen->setSize(32*8, 24*8);
  screen->setScale(1.0, 1.0);
  screen->setAspect(1.0, 1.0);
  screen->setViewport(0, 0, screen->width(), screen->height());
  
  
}

auto VDP::unload() -> void {
  screen->quit();
  node->remove(screen);
  screen.reset();
  node.reset();
}

auto VDP::step(u32 clocks) -> void {
  Thread::step(clocks);
  Thread::synchronize(cpu);
}

auto VDP::read(n16 address) -> u8 {
	return 0;
}
auto VDP::write(u8 data) -> void {
  char aChar = data & 0x7f;
  print("VIDEO IN: ");
  print(data);
  print(" - \"");
  print(aChar);
  print("\"\n");
  return;
}


auto VDP::frame() -> void {
  screen->frame();
  scheduler.exit(Event::Frame);
}

auto VDP::power() -> void {
  Thread::create(system.frequency()/2, [&] { main(); });
  screen->power();
  cursx = 3;
  cursy = 1;
}

}
